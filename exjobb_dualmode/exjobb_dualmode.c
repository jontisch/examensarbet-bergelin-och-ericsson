/*
 * This file has been automatically generated by the WICED 20719-B1 Designer.
 * Bluetooth Application.
 *
 */

/** exjobb_dualmode.c
 *
 */

#include "wiced.h"
#include "wiced_gki.h"
#include "wiced_bt_dev.h"
#include "wiced_bt_ble.h"
#include "wiced_bt_uuid.h"
#include "wiced_bt_gatt.h"
#include "wiced_hci.h"
#include "wiced_timer.h"
#include "wiced_hal_nvram.h"
#include "wiced_hal_gpio.h"
#include "wiced_bt_app_hal_common.h"
#include "wiced_hal_platform.h"
#include "wiced_hal_wdog.h"
#include "wiced_bt_trace.h"
#include "wiced_bt_stack.h"
#include "wiced_bt_sdp.h"
#include "wiced_bt_spp.h"
#include "wiced_bt_app_common.h"
#include "wiced_memory.h"
#include "sparcommon.h"
#include "string.h"
#include "stdbool.h"
#include "hci_control_api.h"
#include "wiced_transport.h"
#include "wiced_hal_pspi.h"
#include "exjobb_dualmode_db.h"
#include "exjobb_dualmode_sdp_db.h"
#include "wiced_bt_cfg.h"


/*******************************************************************
 * Constant Definitions
 ******************************************************************/
#define TRANS_UART_BUFFER_COUNT 10

#define WICED_EIR_BUF_MAX_SIZE              264
#define SPP_NVRAM_ID                        WICED_NVRAM_VSID_START

/* Max TX packet to be sent over SPP */
#define MAX_TX_BUFFER                       1017
#define TRANS_MAX_BUFFERS                   10
#define TRANS_UART_BUFFER_SIZE              1024
#define SPP_MAX_PAYLOAD                     1007
/*******************************************************************
 * Variable Definitions
 ******************************************************************/
extern const wiced_bt_cfg_settings_t wiced_bt_cfg_settings;
extern const wiced_bt_cfg_buf_pool_t wiced_bt_cfg_buf_pools[WICED_BT_CFG_NUM_BUF_POOLS];
// Transport pool for sending RFCOMM data to host
static wiced_transport_buffer_pool_t* transport_pool = NULL;

/*******************************************************************
 * Function Prototypes
 ******************************************************************/
static void                   exjobb_dualmode_app_init               ( void );
static wiced_bt_dev_status_t  exjobb_dualmode_management_callback    ( wiced_bt_management_evt_t event, wiced_bt_management_evt_data_t *p_event_data );
static void                   exjobb_dualmode_set_advertisement_data ( void );
static void                   exjobb_dualmode_advertisement_stopped  ( void );
static void                   exjobb_dualmode_reset_device           ( void );
/* GATT Registration Callbacks */
static wiced_bt_gatt_status_t exjobb_dualmode_write_handler          ( wiced_bt_gatt_write_t *p_write_req, uint16_t conn_id );
static wiced_bt_gatt_status_t exjobb_dualmode_read_handler           ( wiced_bt_gatt_read_t *p_read_req, uint16_t conn_id );
static wiced_bt_gatt_status_t exjobb_dualmode_connect_callback       ( wiced_bt_gatt_connection_status_t *p_conn_status );
static wiced_bt_gatt_status_t exjobb_dualmode_server_callback        ( uint16_t conn_id, wiced_bt_gatt_request_type_t type, wiced_bt_gatt_request_data_t *p_data );
static wiced_bt_gatt_status_t exjobb_dualmode_event_handler          ( wiced_bt_gatt_evt_t  event, wiced_bt_gatt_event_data_t *p_event_data );
static uint32_t               hci_control_process_rx_cmd             ( uint8_t* p_data, uint32_t len );
#ifdef HCI_TRACE_OVER_TRANSPORT
static void                   exjobb_dualmode_trace_callback         ( wiced_bt_hci_trace_type_t type, uint16_t length, uint8_t* p_data );
#endif


static void                  app_write_eir(void);
static int                   app_write_nvram(int nvram_id, int data_len, void *p_data);
static int                   app_read_nvram(int nvram_id, void *p_data, int data_len);

#define SPP_RFCOMM_SCN                  1
#define LOOPBACK_DATA 0

#define TRACE_STATUS_DATA 0

static void         spp_connection_up_callback(uint16_t handle, uint8_t* bda);
static void         spp_connection_down_callback(uint16_t handle);
static wiced_bool_t spp_rx_data_callback(uint16_t handle, uint8_t* p_data, uint32_t data_len);
wiced_bt_spp_reg_t spp_reg =
{
        SPP_RFCOMM_SCN,                     /* RFCOMM service channel number for SPP connection */
        MAX_TX_BUFFER,                      /* RFCOMM MTU for SPP connection */
        spp_connection_up_callback,         /* SPP connection established */
        NULL,                               /* SPP connection establishment failed, not used because this app never initiates connection */
        NULL,                               /* SPP service not found, not used because this app never initiates connection */
        spp_connection_down_callback,       /* SPP connection disconnected */
        spp_rx_data_callback,               /* Data packet received */
};

uint16_t                        spp_handle;
uint8_t pincode[4] = { 0x30, 0x30, 0x30, 0x30 };

/*******************************************************************
 * Macro Definitions
 ******************************************************************/
// Macro to extract uint16_t from little-endian byte array
#define LITTLE_ENDIAN_BYTE_ARRAY_TO_UINT16(byte_array) \
        (uint16_t)( ((byte_array)[0] | ((byte_array)[1] << 8)) )

/*******************************************************************
 * Transport Configuration
 ******************************************************************/
wiced_transport_cfg_t transport_cfg =
{
        WICED_TRANSPORT_UART,              /**< Wiced transport type. */
        { WICED_TRANSPORT_UART_HCI_MODE, HCI_UART_DEFAULT_BAUD },
        { TRANS_UART_BUFFER_SIZE, TRANS_UART_BUFFER_COUNT },
        NULL,                              /**< Wiced transport status handler.*/
        NULL, //hci_control_process_rx_cmd,        /**< Wiced transport receive data handler. */
        NULL                               /**< Wiced transport tx complete callback. */
};

/*******************************************************************
 * GATT Initial Value Arrays
 ******************************************************************/
uint8_t exjobb_dualmode_generic_access_device_name[]                 = {'e','x','j','o','b','b','_','d','u','a','l','m','o','d','e'};
uint8_t exjobb_dualmode_generic_access_appearance[]                  = {0x00,0x00};
uint8_t exjobb_dualmode_custom_serial_gatt_rx[512];
uint8_t exjobb_dualmode_custom_serial_gatt_rx_user_description[]     = {'R','X',' ','c','h','a','r','a','c','t','e','r','i','s','t','i','c'};
uint8_t exjobb_dualmode_custom_serial_gatt_rx_client_configuration[] = {BIT16_TO_8(GATT_CLIENT_CONFIG_NONE)};
uint8_t exjobb_dualmode_custom_serial_gatt_tx[512];
uint8_t exjobb_dualmode_custom_serial_gatt_tx_user_description[]     = {'T','X',' ','C','h','a','r','a','c','t','e','r','i','s','t','i','c'};

/*******************************************************************
 * GATT Lookup Table
 ******************************************************************/

/* GATT attribute lookup table                                */
/* (attributes externally referenced by GATT server database) */
gatt_db_lookup_table exjobb_dualmode_gatt_db_ext_attr_tbl[] =
{
        /* { attribute handle,                            maxlen,                                                         curlen,                                                         attribute data } */
        {HDLC_GENERIC_ACCESS_DEVICE_NAME_VALUE,           15,                                                             15,                                                             exjobb_dualmode_generic_access_device_name},
        {HDLC_GENERIC_ACCESS_APPEARANCE_VALUE,            2,                                                              2,                                                              exjobb_dualmode_generic_access_appearance},
        {HDLC_CUSTOM_SERIAL_GATT_RX_VALUE,                512,                                                            241,                                                            exjobb_dualmode_custom_serial_gatt_rx},
        {HDLD_CUSTOM_SERIAL_GATT_RX_USER_DESCRIPTION,     sizeof(exjobb_dualmode_custom_serial_gatt_rx_user_description), sizeof(exjobb_dualmode_custom_serial_gatt_rx_user_description), exjobb_dualmode_custom_serial_gatt_rx_user_description},
        {HDLD_CUSTOM_SERIAL_GATT_RX_CLIENT_CONFIGURATION, 2,                                                              2,                                                              exjobb_dualmode_custom_serial_gatt_rx_client_configuration},
        {HDLC_CUSTOM_SERIAL_GATT_TX_VALUE,                512,                                                            241,                                                            exjobb_dualmode_custom_serial_gatt_tx},
        {HDLD_CUSTOM_SERIAL_GATT_TX_USER_DESCRIPTION,     sizeof(exjobb_dualmode_custom_serial_gatt_tx_user_description), sizeof(exjobb_dualmode_custom_serial_gatt_tx_user_description), exjobb_dualmode_custom_serial_gatt_tx_user_description},
};

// Number of Lookup Table Entries
const uint16_t exjobb_dualmode_gatt_db_ext_attr_tbl_size = ( sizeof ( exjobb_dualmode_gatt_db_ext_attr_tbl ) / sizeof ( gatt_db_lookup_table ) );
/*******************************************************************
 * Custom Data containers

 ******************************************************************/

#define RECEIVE_SIZE 50000
#define RETURN_LENGTH 25
uint8_t receive_buffer[100000];
uint16_t spp_send_handle=0;
uint32_t current_write_pos = 0;
uint32_t data_bytes=0,data_errors=0,data_faulty=0,data_timer=0;
char return_string[RETURN_LENGTH];

uint16_t ble_id=0;
uint32_t timer =0,param=0;
bool timer_flag= false, bt_version;
wiced_timer_t wiced_timer;
uint32_t ms_since_last = 0;
#define PACKET_TIMEOUT 1000
/*******************************************************************
 * Function Definitions
 ******************************************************************/
void *timer_callback(uint32_t param){
//    snprintf(return_string,sizeof(return_string),"\tBytes: %d\tErrors: %d\tFaultybytes: %d\tTime ms: %d\t\n",data_bytes,data_errors,data_faulty,data_timer);
    timer++;
    if(ms_since_last++ > PACKET_TIMEOUT){
        current_write_pos = 0;
        wiced_stop_timer(&wiced_timer);
        timer = 0;
        timer_flag=false;
        WICED_BT_TRACE("TIMEOUT\n\n");
        //TODO
        snprintf(return_string,RETURN_LENGTH,"%05d\t%05d\t%05d\t%05d\n\n",data_bytes,data_errors,data_faulty,data_timer);
        if(bt_version)//U=R*I    5
        {
            //br
            wiced_bt_spp_send_session_data(spp_send_handle, return_string, RETURN_LENGTH);
        }
        else
        {
            //ble
            for(int rxpos = 0; rxpos < RETURN_LENGTH; rxpos++){
                exjobb_dualmode_custom_serial_gatt_rx[rxpos] = return_string[rxpos];
            }
//            wiced_bt_gatt_send_notification(ble_id, HDLC_CUSTOM_SERIAL_GATT_RX_VALUE, RETURN_LENGTH, return_string);
            char ret = 'x';
            wiced_bt_gatt_send_notification(ble_id, HDLC_CUSTOM_SERIAL_GATT_RX_VALUE, 1, &ret);
        }

        //check btversion active
        //send important data
    }
}

/*
 * Entry point to the application. Set device configuration and start BT
 * stack initialization.  The actual application initialization will happen
 * when stack reports that BT device is ready
 */

void application_start(void)
{
    /* Initialize the transport configuration */
    wiced_transport_init( &transport_cfg );

    /* Initialize Transport Buffer Pool */
    transport_pool = wiced_transport_create_buffer_pool ( TRANS_UART_BUFFER_SIZE, TRANS_UART_BUFFER_COUNT );

#if ((defined WICED_BT_TRACE_ENABLE) || (defined HCI_TRACE_OVER_TRANSPORT))
    /* Set the Debug UART as WICED_ROUTE_DEBUG_NONE to get rid of prints */
    //  wiced_set_debug_uart( WICED_ROUTE_DEBUG_NONE );

    /* Set Debug UART as WICED_ROUTE_DEBUG_TO_PUART to see debug traces on Peripheral UART (PUART) */
    wiced_set_debug_uart( WICED_ROUTE_DEBUG_TO_PUART );

    /* Set the Debug UART as WICED_ROUTE_DEBUG_TO_WICED_UART to send debug strings over the WICED debug interface */
    //wiced_set_debug_uart( WICED_ROUTE_DEBUG_TO_WICED_UART );
#endif

    /* Initialize Bluetooth Controller and Host Stack */
    wiced_bt_stack_init(exjobb_dualmode_management_callback, &wiced_bt_cfg_settings, wiced_bt_cfg_buf_pools);

    wiced_init_timer(&wiced_timer,timer_callback,param,WICED_MILLI_SECONDS_PERIODIC_TIMER);
}

/*
 * This function is executed in the BTM_ENABLED_EVT management callback.
 */
void exjobb_dualmode_app_init(void)
{

    app_write_eir();

    wiced_bt_spp_startup(&spp_reg);

    /* Initialize Application */
    wiced_bt_app_init();

    /* Allow peer to pair */
    wiced_bt_set_pairable_mode(WICED_TRUE, 0);

    /* Set Advertisement Data */
    exjobb_dualmode_set_advertisement_data();

    /* Register with stack to receive GATT callback */
    wiced_bt_gatt_register( exjobb_dualmode_event_handler );

    /* Initialize GATT Database */
    wiced_bt_gatt_db_init( gatt_database, gatt_database_len );

    /* Initialize SDP Database */
    wiced_bt_sdp_db_init( (uint8_t*)sdp_database, sdp_database_len );

    /* Start Undirected LE Advertisements on device startup.
     * The corresponding parameters are contained in 'wiced_bt_cfg.c' */
    /* TODO: Make sure that this is the desired behavior. */
    wiced_bt_start_advertisements(BTM_BLE_ADVERT_UNDIRECTED_HIGH, 0, NULL);

    /* Make device connectable (enables page scan) using default connectability window/interval.
     * The corresponding parameters are contained in 'wiced_bt_cfg.c' */
    /* TODO: Make sure that this is the desired behavior. */
    wiced_bt_dev_set_connectability(BTM_CONNECTABLE, BTM_DEFAULT_CONN_WINDOW, BTM_DEFAULT_CONN_INTERVAL);

    /* Make device discoverable (enables inquiry scan) over BR/EDR using default discoverability window/interval.
     * The corresponding parameters are contained in 'wiced_bt_cfg.c' */
    /* TODO: Make sure that this is the desired behavior. */
    wiced_bt_dev_set_discoverability(BTM_GENERAL_DISCOVERABLE, BTM_DEFAULT_DISC_WINDOW, BTM_DEFAULT_DISC_INTERVAL);
}

/* Set Advertisement Data */
void exjobb_dualmode_set_advertisement_data( void )
{
    wiced_bt_ble_advert_elem_t adv_elem[2] = { 0 };
    uint8_t adv_flag = BTM_BLE_GENERAL_DISCOVERABLE_FLAG | BTM_BLE_BREDR_NOT_SUPPORTED;
    uint8_t num_elem = 0; 

    /* Advertisement Element for Flags */
    adv_elem[num_elem].advert_type = BTM_BLE_ADVERT_TYPE_FLAG;
    adv_elem[num_elem].len = sizeof(uint8_t);
    adv_elem[num_elem].p_data = &adv_flag;
    num_elem++;

    /* Advertisement Element for Name */
    adv_elem[num_elem].advert_type = BTM_BLE_ADVERT_TYPE_NAME_COMPLETE;
    adv_elem[num_elem].len = strlen((const char*)BT_LOCAL_NAME);
    adv_elem[num_elem].p_data = BT_LOCAL_NAME;
    num_elem++;

    /* Set Raw Advertisement Data */
    wiced_bt_ble_set_raw_advertisement_data(num_elem, adv_elem);
}

/* This function is invoked when advertisements stop */
void exjobb_dualmode_advertisement_stopped( void )
{
    WICED_BT_TRACE("Advertisement stopped\n");

    /* TODO: Handle when advertisements stop */
}

/* TODO: This function should be called when the device needs to be reset */
void exjobb_dualmode_reset_device( void )
{
    /* TODO: Clear any additional persistent values used by the application from NVRAM */

    // Reset the device
    wiced_hal_wdog_reset_system( );
}

/* Bluetooth Management Event Handler */
wiced_bt_dev_status_t exjobb_dualmode_management_callback( wiced_bt_management_evt_t event, wiced_bt_management_evt_data_t *p_event_data )
{
    wiced_bt_dev_status_t status = WICED_BT_SUCCESS;
    wiced_bt_device_address_t bda = { 0 };
    wiced_bt_dev_br_edr_pairing_info_t *p_br_edr_info = NULL;
    wiced_bt_dev_encryption_status_t*   p_encryption_status;
    wiced_bt_dev_ble_pairing_info_t *p_ble_info = NULL;
    wiced_bt_ble_advert_mode_t *p_adv_mode = NULL;
    wiced_bt_power_mgmt_notification_t* p_power_mgmt_notification;

#if TRACE_STATUS_DATA
    WICED_BT_TRACE("\nevent: %d event_data\n\n", event);
#endif

    switch (event)
    {
    case BTM_ENABLED_EVT:
        /* Bluetooth Controller and Host Stack Enabled */

#ifdef HCI_TRACE_OVER_TRANSPORT
        // There is a virtual HCI interface between upper layers of the stack and
        // the controller portion of the chip with lower layers of the BT stack.
        // Register with the stack to receive all HCI commands, events and data.
        wiced_bt_dev_register_hci_trace(exjobb_dualmode_trace_callback);
#endif

        WICED_BT_TRACE("Bluetooth Enabled (%s)\n",
                ((WICED_BT_SUCCESS == p_event_data->enabled.status) ? "success" : "failure"));

        if (WICED_BT_SUCCESS == p_event_data->enabled.status)
        {
            /* Bluetooth is enabled */
            wiced_bt_dev_read_local_addr(bda);
            WICED_BT_TRACE("Local Bluetooth Address: [%B]\n", bda);

            /* Perform application-specific initialization */
            exjobb_dualmode_app_init();
        }
        break;
    case BTM_DISABLED_EVT:
        /* Bluetooth Controller and Host Stack Disabled */
        WICED_BT_TRACE("Bluetooth Disabled\n");
        break;

    case BTM_PIN_REQUEST_EVT:
        WICED_BT_TRACE("remote address= %B\n", p_event_data->pin_request.bd_addr);
        wiced_bt_dev_pin_code_reply(*p_event_data->pin_request.bd_addr,status/*WICED_BT_SUCCESS*/,4, &pincode[0]);
        break;

    case BTM_SECURITY_REQUEST_EVT:
        /* Security Request */
#if TRACE_STATUS_DATA
        WICED_BT_TRACE("Security Request\n");
#endif
        wiced_bt_ble_security_grant(p_event_data->security_request.bd_addr, WICED_BT_SUCCESS);
        break;
    case BTM_PAIRING_IO_CAPABILITIES_BR_EDR_REQUEST_EVT:
        /* Request for Pairing IO Capabilities (BR/EDR) */
#if TRACE_STATUS_DATA
        WICED_BT_TRACE("BR/EDR Pairing IO Capabilities Request\n");
#endif
        p_event_data->pairing_io_capabilities_br_edr_request.oob_data = BTM_OOB_NONE;
        p_event_data->pairing_io_capabilities_br_edr_request.auth_req = BTM_AUTH_SINGLE_PROFILE_GENERAL_BONDING_NO; // BYTT FRÅN YES
        p_event_data->pairing_io_capabilities_br_edr_request.is_orig = WICED_FALSE;
        break;
    case BTM_PAIRING_IO_CAPABILITIES_BLE_REQUEST_EVT:
        /* Request for Pairing IO Capabilities (BLE) */
#if TRACE_STATUS_DATA
        WICED_BT_TRACE("BLE Pairing IO Capabilities Request\n");
#endif
        /* No IO Capabilities on this Platform */
        p_event_data->pairing_io_capabilities_ble_request.local_io_cap = BTM_IO_CAPABILITIES_NONE;
        p_event_data->pairing_io_capabilities_ble_request.oob_data = BTM_OOB_NONE;
        p_event_data->pairing_io_capabilities_ble_request.auth_req = BTM_LE_AUTH_REQ_BOND|BTM_LE_AUTH_REQ_MITM;
        p_event_data->pairing_io_capabilities_ble_request.max_key_size = 0x10;
        p_event_data->pairing_io_capabilities_ble_request.init_keys = 0;
        p_event_data->pairing_io_capabilities_ble_request.resp_keys = BTM_LE_KEY_PENC|BTM_LE_KEY_PID;
        break;


    case BTM_PAIRING_COMPLETE_EVT:
        /* Pairing is Complete */
        switch (p_event_data->pairing_complete.transport)
        {
        case BT_TRANSPORT_BR_EDR:
            /* BR/EDR Transport */
            p_br_edr_info = &p_event_data->pairing_complete.pairing_complete_info.br_edr;
            WICED_BT_TRACE("BR/EDR Pairing Complete %d.\n", p_br_edr_info->status);
            break;
        case BT_TRANSPORT_LE:
            /* LE Transport */
            p_ble_info = &p_event_data->pairing_complete.pairing_complete_info.ble;
            WICED_BT_TRACE("LE Pairing Complete %d.\n", p_ble_info->reason);
            current_write_pos = 0;
            break;
        default:
            // Unexpected Transport Type
            status = WICED_BT_BADARG;
            break;
        }
        break;
        case BTM_ENCRYPTION_STATUS_EVT:
            /* Encryption Status Change */
            p_encryption_status = &p_event_data->encryption_status;
#if TRACE_STATUS_DATA
            WICED_BT_TRACE("Encryption Status event: bd ( %B ) res %d\n", p_event_data->encryption_status.bd_addr, p_event_data->encryption_status.result);
#endif
            break;
        case BTM_PAIRED_DEVICE_LINK_KEYS_UPDATE_EVT:
#if TRACE_STATUS_DATA
            WICED_BT_TRACE("Paired Device Link Update Keys Event\n");
#endif
            /* This application supports a single paired host, we can save keys under the same NVRAM ID overwriting previous pairing if any */
            app_write_nvram(SPP_NVRAM_ID, sizeof(wiced_bt_device_link_keys_t), &p_event_data->paired_device_link_keys_update);
            break;

        case BTM_PAIRED_DEVICE_LINK_KEYS_REQUEST_EVT:
            /* Paired Device Link Keys Request */
            WICED_BT_TRACE("Paired Device Link Request Keys Event\n");
            /* Device/app-specific TODO: HANDLE PAIRED DEVICE LINK REQUEST KEY - retrieve from NVRAM, etc */
            if(app_read_nvram(SPP_NVRAM_ID, &p_event_data->paired_device_link_keys_request, sizeof(wiced_bt_device_link_keys_t)) != 0)
                //if (exjobb_dualmode_read_link_keys( &p_event_data->paired_device_link_keys_request ))
            {
                WICED_BT_TRACE("Key Retrieval Success\n");
            }
            else
                /* Until key retrieval implemented above, just fail the request - will cause re-pairing */
            {
                WICED_BT_TRACE("Key Retrieval Failure\n");
                status = WICED_BT_ERROR;
            }
            break;
        case BTM_BLE_ADVERT_STATE_CHANGED_EVT:
            /* Advertisement State Changed */
            p_adv_mode = &p_event_data->ble_advert_state_changed;
#if TRACE_STATUS_DATA
            WICED_BT_TRACE("Advertisement State Change: %d\n", *p_adv_mode);
#endif
            if ( BTM_BLE_ADVERT_OFF == *p_adv_mode )
            {
                exjobb_dualmode_advertisement_stopped();
            }
            break;
        case BTM_USER_CONFIRMATION_REQUEST_EVT:
            /* Pairing request, TODO: handle confirmation of numeric compare here if desired */
#if TRACE_STATUS_DATA
            WICED_BT_TRACE("numeric_value: %d\n", p_event_data->user_confirmation_request.numeric_value);
#endif
            wiced_bt_dev_confirm_req_reply( WICED_BT_SUCCESS , p_event_data->user_confirmation_request.bd_addr);
            break;
        case BTM_POWER_MANAGEMENT_STATUS_EVT:
            p_power_mgmt_notification = &p_event_data->power_mgmt_notification;
#if TRACE_STATUS_DATA
            WICED_BT_TRACE("Power mgmt status event: bd (%B) status:%d hci_status:%d\n", p_power_mgmt_notification->bd_addr, \
                    p_power_mgmt_notification->status, p_power_mgmt_notification->hci_status);
#endif
            break;


        default:
#if TRACE_STATUS_DATA
            WICED_BT_TRACE("Unhandled Bluetooth Management Event: 0x%x (%d)\n", event, event);
#endif
            break;
    }

    return status;
}

/* Get a Value */
wiced_bt_gatt_status_t exjobb_dualmode_get_value( uint16_t attr_handle, uint16_t conn_id, uint8_t *p_val, uint16_t max_len, uint16_t *p_len )
{
    int i = 0;
    wiced_bool_t isHandleInTable = WICED_FALSE;
    wiced_bt_gatt_status_t res = WICED_BT_GATT_INVALID_HANDLE;
    // Check for a matching handle entry
    for (i = 0; i < exjobb_dualmode_gatt_db_ext_attr_tbl_size; i++)
    {
        if (exjobb_dualmode_gatt_db_ext_attr_tbl[i].handle == attr_handle)
        {
            // Detected a matching handle in external lookup table
            isHandleInTable = WICED_TRUE;
            // Detected a matching handle in the external lookup table
            if (exjobb_dualmode_gatt_db_ext_attr_tbl[i].cur_len <= max_len)
            {
                WICED_BT_TRACE("RX current length: %d max length:%d\n\n", exjobb_dualmode_gatt_db_ext_attr_tbl[i].cur_len, max_len);
                // Value fits within the supplied buffer; copy over the value
                //*p_len = exjobb_dualmode_gatt_db_ext_attr_tbl[i].cur_len;
                *p_len = RETURN_LENGTH;
                memcpy(p_val, exjobb_dualmode_gatt_db_ext_attr_tbl[i].p_data,*p_len);// exjobb_dualmode_gatt_db_ext_attr_tbl[i].cur_len);
                res = WICED_BT_GATT_SUCCESS;

                // TODO: Add code for any action required when this attribute is read
                switch ( attr_handle )
                {
                case HDLC_GENERIC_ACCESS_DEVICE_NAME_VALUE:
                    break;
                case HDLC_GENERIC_ACCESS_APPEARANCE_VALUE:
                    break;
                case HDLC_CUSTOM_SERIAL_GATT_RX_VALUE:

                    WICED_BT_TRACE("Transmitting rx buffer\n");

                    break;
                case HDLD_CUSTOM_SERIAL_GATT_RX_CLIENT_CONFIGURATION:
                    WICED_BT_TRACE("RX get notification client configuration\n");
                    break;
                }
            }
            else
            {
                // Value to read will not fit within the buffer
                res = WICED_BT_GATT_INVALID_ATTR_LEN;
            }
            break;
        }
    }

    if (!isHandleInTable)
    {
        // TODO: Add code to read value using handles not contained within external lookup table
        // This can apply when the option is enabled to not generate initial value arrays.
        // If the value for the current handle is successfully read then set the result using:
        // res = WICED_BT_GATT_SUCCESS;
        switch ( attr_handle )
        {
        default:
            // The read operation was not performed for the indicated handle
            WICED_BT_TRACE("Read Request to Invalid Handle: 0x%x\n", attr_handle);
            res = WICED_BT_GATT_READ_NOT_PERMIT;
            break;
        }
    }

    return res;
}

/* Set a Value */
wiced_bt_gatt_status_t exjobb_dualmode_set_value( uint16_t attr_handle, uint16_t conn_id, uint8_t *p_val, uint16_t len )
{
    int i = 0;
    wiced_bool_t isHandleInTable = WICED_FALSE;
    wiced_bool_t validLen = WICED_FALSE;
    wiced_bt_gatt_status_t res = WICED_BT_GATT_INVALID_HANDLE;

    // Check for a matching handle entry
    for (i = 0; i < exjobb_dualmode_gatt_db_ext_attr_tbl_size; i++)
    {
        if (exjobb_dualmode_gatt_db_ext_attr_tbl[i].handle == attr_handle)
        {
            // Detected a matching handle in external lookup table
            isHandleInTable = WICED_TRUE;
            // Verify that size constraints have been met
            validLen = (exjobb_dualmode_gatt_db_ext_attr_tbl[i].max_len >= len);
            //WICED_BT_TRACE("Length of received packet: %d, max_len: %d\n\n", len, exjobb_dualmode_gatt_db_ext_attr_tbl[i].max_len);
            if (validLen)
            {
                // Value fits within the supplied buffer; copy over the value
                exjobb_dualmode_gatt_db_ext_attr_tbl[i].cur_len = len;
                memcpy(exjobb_dualmode_gatt_db_ext_attr_tbl[i].p_data, p_val, len);
                res = WICED_BT_GATT_SUCCESS;

                // TODO: Add code for any action required when this attribute is written
                // For example you may need to write the value into NVRAM if it needs to be persistent
                switch ( attr_handle )
                {
                case HDLD_CUSTOM_SERIAL_GATT_RX_CLIENT_CONFIGURATION:
                    break;
                case HDLC_CUSTOM_SERIAL_GATT_TX_VALUE: // Mottagen data från mobil
                    ms_since_last = 0;
                    bt_version=false;
                    ble_id = conn_id;
                    if(timer_flag==false )
                    {
                        timer_flag=true;
                        wiced_start_timer(&wiced_timer,1);
                    }
                    for(int pos = 0; pos < len; pos++){
                        receive_buffer[(current_write_pos++)] = exjobb_dualmode_custom_serial_gatt_tx[pos];
                    }

                    if(current_write_pos >= RECEIVE_SIZE){
                        wiced_stop_timer(&wiced_timer);
                        // Eventuellt göra en timeout också
                        timer_flag=false;

                        data_bytes=current_write_pos;
                        WICED_BT_TRACE("\n-----------------------\nTesting BLE bytes: %d B\n-----------------------\n", current_write_pos);
                        // Testa så att datan inte är korrupt.
                        uint32_t errors = 0,n_wrongbytes=0;
                        //WICED_BT_TRACE("0x%02X ",receive_buffer[0]);
                        for(int pos = 1; pos < RECEIVE_SIZE; pos++){
                            //WICED_BT_TRACE("0x%02X ",receive_buffer[pos]);
                            if(receive_buffer[pos]== 0xff)
                            {
                                n_wrongbytes++;
                            }
                            else if(receive_buffer[pos] != (receive_buffer[pos-1] + 1)%255)
                            {
                                errors++;
                            }

                        }

                        data_timer= timer;
                        WICED_BT_TRACE("\n-----------------------\n%d ms\n-----------------------\n", timer);
                        data_errors=errors;
                        WICED_BT_TRACE("\n-----------------------\n%d errors found\n-----------------------\n", errors);
                        data_faulty=n_wrongbytes;
                        WICED_BT_TRACE("\n-----------------------\n%d faulty bytes found\n-----------------------\n", n_wrongbytes);
                        timer=0;
                        current_write_pos = 0;

                        // Paketera data inför återskick

//                        for(int rxpos = 0; rxpos < RETURN_LENGTH; rxpos++){
//                            exjobb_dualmode_custom_serial_gatt_rx[rxpos] = return_string[rxpos];
//                        }
////                        // Notifiera att det finns data
//                        uint8_t back = return_length;
//                        wiced_bt_gatt_send_notification(conn_id, HDLC_CUSTOM_SERIAL_GATT_RX_VALUE, 1,&back);
                    }
                    break;

                }
            }
            else
            {
                // Value to write does not meet size constraints
                res = WICED_BT_GATT_INVALID_ATTR_LEN;
            }
            break;
        }
    }

    if (!isHandleInTable)
    {
        // TODO: Add code to write value using handles not contained within external lookup table
        // This can apply when the option is enabled to not generate initial value arrays.
        // If the value for the current handle is successfully written then set the result using:
        // res = WICED_BT_GATT_SUCCESS;
        switch ( attr_handle )
        {
        default:
            // The write operation was not performed for the indicated handle
            WICED_BT_TRACE("Write Request to Invalid Handle: 0x%x\n", attr_handle);
            res = WICED_BT_GATT_WRITE_NOT_PERMIT;
            break;
        }
    }

    return res;
}

/* Handles Write Requests received from Client device */
wiced_bt_gatt_status_t exjobb_dualmode_write_handler( wiced_bt_gatt_write_t *p_write_req, uint16_t conn_id )
{
    wiced_bt_gatt_status_t status = WICED_BT_GATT_INVALID_HANDLE;

    /* Attempt to perform the Write Request */
    status = exjobb_dualmode_set_value(p_write_req->handle, conn_id, p_write_req->p_val, p_write_req->val_len);

    return status;
}

/* Handles Read Requests received from Client device */
wiced_bt_gatt_status_t exjobb_dualmode_read_handler( wiced_bt_gatt_read_t *p_read_req, uint16_t conn_id )
{
    wiced_bt_gatt_status_t status = WICED_BT_GATT_INVALID_HANDLE;

    /* Attempt to perform the Read Request */
    status = exjobb_dualmode_get_value(p_read_req->handle, conn_id, p_read_req->p_val, *p_read_req->p_val_len, p_read_req->p_val_len);

    return status;
}

/* GATT Connection Status Callback */
wiced_bt_gatt_status_t exjobb_dualmode_connect_callback( wiced_bt_gatt_connection_status_t *p_conn_status )
{
    wiced_bt_gatt_status_t status = WICED_BT_GATT_ERROR;

    if ( NULL != p_conn_status )
    {
        if ( p_conn_status->connected )
        {
            // Device has connected
            /* Set the preferred PHY */

            wiced_bt_ble_phy_preferences_t pref = {
                    {0,0,0,0,0,0},
                    BTM_BLE_PREFER_2M_PHY,
                    BTM_BLE_PREFER_2M_PHY,
                    BTM_BLE_PREFER_CODED_PHY_NONE
            };
            for(int i = 0; i < 6; i++){
                pref.remote_bd_addr[i] = p_conn_status->bd_addr[i];
            }
            wiced_bt_dev_status_t phy_status = wiced_bt_ble_set_phy(&pref);

            WICED_BT_TRACE("Connected : BDA '%B', Connection ID '%d', PHY status: %d\n",
                    p_conn_status->bd_addr,
                    p_conn_status->conn_id,
                    phy_status );


            /* TODO: Handle the connection */
        }
        else
        {
            // Device has disconnected
            WICED_BT_TRACE("Disconnected : BDA '%B', Connection ID '%d', Reason '%d'\n", p_conn_status->bd_addr, p_conn_status->conn_id, p_conn_status->reason );

            /* TODO: Handle the disconnection */

            /* restart the advertisements */
            wiced_bt_start_advertisements(BTM_BLE_ADVERT_UNDIRECTED_HIGH, 0, NULL);
        }
        status = WICED_BT_GATT_SUCCESS;
    }

    return status;
}

/* GATT Server Event Callback */
wiced_bt_gatt_status_t exjobb_dualmode_server_callback( uint16_t conn_id, wiced_bt_gatt_request_type_t type, wiced_bt_gatt_request_data_t *p_data )
{
    wiced_bt_gatt_status_t status = WICED_BT_GATT_ERROR;

    switch ( type )
    {
    case GATTS_REQ_TYPE_READ:
        status = exjobb_dualmode_read_handler( &p_data->read_req, conn_id );
        break;
    case GATTS_REQ_TYPE_WRITE:
        status = exjobb_dualmode_write_handler( &p_data->write_req, conn_id );
        break;
    }

    return status;
}

/* GATT Event Handler */
wiced_bt_gatt_status_t exjobb_dualmode_event_handler( wiced_bt_gatt_evt_t event, wiced_bt_gatt_event_data_t *p_event_data )
{
    wiced_bt_gatt_status_t status = WICED_BT_GATT_ERROR;
    wiced_bt_gatt_connection_status_t *p_conn_status = NULL;
    wiced_bt_gatt_attribute_request_t *p_attr_req = NULL;

    switch ( event )
    {
    case GATT_CONNECTION_STATUS_EVT:
        status = exjobb_dualmode_connect_callback( &p_event_data->connection_status );
        break;
    case GATT_ATTRIBUTE_REQUEST_EVT:
        p_attr_req = &p_event_data->attribute_request;
        status = exjobb_dualmode_server_callback( p_attr_req->conn_id, p_attr_req->request_type, &p_attr_req->data );
        break;
    default:
        status = WICED_BT_GATT_SUCCESS;
        break;
    }

    return status;
}

/* Handle Command Received over Transport */
uint32_t hci_control_process_rx_cmd( uint8_t* p_data, uint32_t len )
{
    uint8_t status = 0;
    uint8_t cmd_status = HCI_CONTROL_STATUS_SUCCESS;
    uint8_t opcode = 0;
    uint8_t* p_payload_data = NULL;
    uint8_t payload_length = 0;

    WICED_BT_TRACE("hci_control_process_rx_cmd : Data Length '%d'\n", len);

    // At least 4 bytes are expected in WICED Header
    if ((NULL == p_data) || (len < 4))
    {
        WICED_BT_TRACE("Invalid Parameters\n");
        status = HCI_CONTROL_STATUS_INVALID_ARGS;
    }
    else
    {
        // Extract OpCode and Payload Length from little-endian byte array
        opcode = LITTLE_ENDIAN_BYTE_ARRAY_TO_UINT16(p_data);
        payload_length = LITTLE_ENDIAN_BYTE_ARRAY_TO_UINT16(&p_data[sizeof(uint16_t)]);
        p_payload_data = &p_data[sizeof(uint16_t)*2];

        // TODO : Process received HCI Command based on its Control Group
        // (see 'hci_control_api.h' for additional details)
        switch ( HCI_CONTROL_GROUP(opcode) )
        {
        default:
            // HCI Control Group was not handled
            cmd_status = HCI_CONTROL_STATUS_UNKNOWN_GROUP;
            wiced_transport_send_data(HCI_CONTROL_EVENT_COMMAND_STATUS, &cmd_status, sizeof(cmd_status));
            break;
        }
    }

    // When operating in WICED_TRANSPORT_UART_HCI_MODE or WICED_TRANSPORT_SPI,
    // application has to free buffer in which data was received
    wiced_transport_free_buffer( p_data );
    p_data = NULL;

    return status;
}


/*
 *  Prepare extended inquiry response data.  Current version publishes device name and 16bit
 *  SPP service.
 */
void app_write_eir(void)
{
    uint8_t *pBuf;
    uint8_t *p;
    uint8_t length;
    uint16_t eir_length;

    pBuf = (uint8_t *)wiced_bt_get_buffer(WICED_EIR_BUF_MAX_SIZE);
    WICED_BT_TRACE("hci_control_write_eir %x\n", pBuf);

    if (!pBuf)
    {
        WICED_BT_TRACE("app_write_eir %x\n", pBuf);
        return;
    }

    p = pBuf;

    length = strlen((char *)wiced_bt_cfg_settings.device_name);

    *p++ = length + 1;
    *p++ = BT_EIR_COMPLETE_LOCAL_NAME_TYPE;        // EIR type full name
    memcpy(p, wiced_bt_cfg_settings.device_name, length);
    p += length;

    *p++ = 2 + 1;                                   // Length of 16 bit services
    *p++ = BT_EIR_COMPLETE_16BITS_UUID_TYPE;        // 0x03 EIR type full list of 16 bit service UUIDs
    *p++ = UUID_SERVCLASS_SERIAL_PORT & 0xff;
    *p++ = (UUID_SERVCLASS_SERIAL_PORT >> 8) & 0xff;

    *p++ = 0;                                       // end of EIR Data is 0

    eir_length = (uint16_t) (p - pBuf);

    // print EIR data
    wiced_bt_trace_array("EIR :", pBuf, MIN(p-pBuf, 100));
    wiced_bt_dev_write_eir(pBuf, eir_length);

    return;
}

/*
 * SPP connection up callback
 */
void spp_connection_up_callback(uint16_t handle, uint8_t* bda)
{
    WICED_BT_TRACE("%s handle:%d address:%B\n", __FUNCTION__, handle, bda);
    spp_handle = handle;
}

/*
 * SPP connection down callback
 */
void spp_connection_down_callback(uint16_t handle)
{
    WICED_BT_TRACE("%s handle:%d\n", __FUNCTION__, handle);
    spp_handle = 0;
}
/*
 * Process data received over EA session.  Return TRUE if we were able to allocate buffer to
 * deliver to the host.
 */
wiced_bool_t spp_rx_data_callback(uint16_t handle, uint8_t* p_data, uint32_t data_len)
{
    spp_send_handle = handle;
    // Här tar vi emot BR/EDR
    ms_since_last = 0;
    bt_version=true;
    if(timer_flag==false )
    {
        timer_flag=true;
        wiced_start_timer(&wiced_timer,1);
    }
    for(int pos = 0; pos < data_len; pos++){
        receive_buffer[(current_write_pos++)] = p_data[pos];
    }

    if(current_write_pos >= RECEIVE_SIZE){ // Eventuellt göra en timeout också
        wiced_stop_timer(&wiced_timer);
        timer_flag=false;
        data_bytes = current_write_pos;
        WICED_BT_TRACE("\n-----------------------\nTesting BR/EDR errors: %d B\n-----------------------\n", current_write_pos);

        // Testa så att datan inte är korrupt.
        uint32_t errors = 0, n_wrongbytes=0;
        //WICED_BT_TRACE("0x%02X ",receive_buffer[0]);
        for(int pos = 1; pos < RECEIVE_SIZE; pos++){
            //WICED_BT_TRACE("0x%02X ",receive_buffer[pos]);
            if(receive_buffer[pos]==0xff)
            {
                n_wrongbytes++;
            }
            else if(receive_buffer[pos] != (receive_buffer[pos-1] + 1)%255){
                errors++;
            }
        }
        data_timer= timer;
        WICED_BT_TRACE("\n-----------------------\n%d ms\n-----------------------\n", timer);
        data_errors = errors;
        WICED_BT_TRACE("\n-----------------------\n%d errors found\n-----------------------\n", errors);
        data_faulty = n_wrongbytes;
        WICED_BT_TRACE("\n-----------------------\n%d faulty bytes\n-----------------------\n", n_wrongbytes);
        current_write_pos = 0;
        timer=0;
        // Paketera data inför återskick
        //snprintf(return_string,RETURN_LENGTH,"%05d\t%05d\t%05d\t%05d\n",data_bytes,data_errors,data_faulty,data_timer);

        // Notifiera att det finns data
        //wiced_bt_spp_send_session_data(handle, return_string, return_length);
    }
    //WICED_BT_TRACE("%s handle:%d len:%d %02x-%02x\n", __FUNCTION__, handle, data_len, p_data[0], p_data[data_len - 1]);

#if LOOPBACK_DATA
    wiced_bt_spp_send_session_data(handle, p_data, data_len);
#endif
    return WICED_TRUE;
}

/*
 * Write NVRAM function is called to store information in the NVRAM.
 */
int app_write_nvram(int nvram_id, int data_len, void *p_data)
{
    wiced_result_t  result;
    int             bytes_written = wiced_hal_write_nvram(nvram_id, data_len, (uint8_t*)p_data, &result);

    WICED_BT_TRACE("NVRAM ID:%d written :%d bytes result:%d\n", nvram_id, bytes_written, result);
    return (bytes_written);
}

/*
 * Read data from the NVRAM and return in the passed buffer
 */
int app_read_nvram(int nvram_id, void *p_data, int data_len)
{
    uint16_t        read_bytes = 0;
    wiced_result_t  result;

    if (data_len >= sizeof(wiced_bt_device_link_keys_t))
    {
        read_bytes = wiced_hal_read_nvram(nvram_id, sizeof(wiced_bt_device_link_keys_t), p_data, &result);
        WICED_BT_TRACE("NVRAM ID:%d read out of %d bytes:%d result:%d\n", nvram_id, sizeof(wiced_bt_device_link_keys_t), read_bytes, result);
    }
    return (read_bytes);
}


#ifdef HCI_TRACE_OVER_TRANSPORT
/* Handle Sending of Trace over the Transport */
void exjobb_dualmode_trace_callback( wiced_bt_hci_trace_type_t type, uint16_t length, uint8_t* p_data )
{
    wiced_transport_send_hci_trace( transport_pool, type, length, p_data );
}
#endif
